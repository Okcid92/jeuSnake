<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Mega Ultimate - Version Web</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #fff;
            background: #000;
        }
        
        .controls {
            margin: 20px 0;
            text-align: center;
        }
        
        .score {
            font-size: 24px;
            margin: 10px 0;
        }
        
        .instructions {
            max-width: 600px;
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <h1>üêç Snake Mega Ultimate Edition</h1>
    
    <div class="score">
        <span id="score">Score: 0</span>
        <span id="level" style="margin-left: 20px;">Niveau: 1</span>
    </div>
    
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <button onclick="startGame()">Nouvelle Partie</button>
        <button onclick="togglePause()">Pause</button>
        <button onclick="toggleNightMode()">Mode Nuit</button>
    </div>
    
    <div class="instructions">
        <h3>üéÆ Contr√¥les :</h3>
        <p><strong>Fl√®ches directionnelles</strong> : D√©placer le snake</p>
        <p><strong>Espace</strong> : Sprint (vitesse x2)</p>
        <p><strong>T</strong> : T√©l√©portation (si disponible)</p>
        
        <h3>üçé Power-ups :</h3>
        <p>üî¥ Rouge: +1 pt | üîµ Bleu: +5 pts | üü° Or: Ralentit | üü£ Violet: R√©duit</p>
        <p>üîµ Cyan: Fant√¥me | üü† Orange: Vitesse | ü©∑ Rose: T√©l√©portation | üü° Jaune: Invincible</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const CELL_SIZE = 20;
        const GRID_WIDTH = canvas.width / CELL_SIZE;
        const GRID_HEIGHT = canvas.height / CELL_SIZE;
        
        let game = {
            snake: [{x: Math.floor(GRID_WIDTH/2), y: Math.floor(GRID_HEIGHT/2)}],
            direction: {x: 1, y: 0},
            food: [],
            score: 0,
            level: 1,
            gameRunning: false,
            paused: false,
            nightMode: false,
            sprinting: false,
            ghostTimer: 0,
            invincibleTimer: 0,
            teleportCharges: 0,
            particles: []
        };
        
        const FRUIT_TYPES = {
            NORMAL: {color: '#ff0000', points: 1},
            BONUS: {color: '#0066ff', points: 5},
            SLOW: {color: '#ffd700', points: 2},
            SHRINK: {color: '#800080', points: 3},
            GHOST: {color: '#00ffff', points: 4},
            SPEED: {color: '#ff6500', points: 3},
            TELEPORT: {color: '#ff69b4', points: 6},
            INVINCIBLE: {color: '#ffff00', points: 8}
        };
        
        function startGame() {
            game.snake = [{x: Math.floor(GRID_WIDTH/2), y: Math.floor(GRID_HEIGHT/2)}];
            game.direction = {x: 1, y: 0};
            game.food = [];
            game.score = 0;
            game.level = 1;
            game.gameRunning = true;
            game.paused = false;
            game.ghostTimer = 0;
            game.invincibleTimer = 0;
            game.teleportCharges = 0;
            game.particles = [];
            
            spawnFood();
            gameLoop();
        }
        
        function spawnFood() {
            while (game.food.length < 5) {
                let pos = {
                    x: Math.floor(Math.random() * GRID_WIDTH),
                    y: Math.floor(Math.random() * GRID_HEIGHT)
                };
                
                // V√©rifier que la position est libre
                let occupied = game.snake.some(segment => segment.x === pos.x && segment.y === pos.y) ||
                              game.food.some(food => food.x === pos.x && food.y === pos.y);
                
                if (!occupied) {
                    let rand = Math.random();
                    let type = 'NORMAL';
                    
                    if (rand < 0.4) type = 'NORMAL';
                    else if (rand < 0.55) type = 'BONUS';
                    else if (rand < 0.68) type = 'SLOW';
                    else if (rand < 0.78) type = 'SHRINK';
                    else if (rand < 0.86) type = 'GHOST';
                    else if (rand < 0.92) type = 'SPEED';
                    else if (rand < 0.97) type = 'TELEPORT';
                    else type = 'INVINCIBLE';
                    
                    game.food.push({...pos, type: type});
                }
            }
        }
        
        function moveSnake() {
            if (game.paused || !game.gameRunning) return;
            
            let head = {
                x: game.snake[0].x + game.direction.x,
                y: game.snake[0].y + game.direction.y
            };
            
            // Collision avec les bords
            if (game.invincibleTimer <= 0) {
                if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
                    gameOver();
                    return;
                }
            } else {
                // T√©l√©portation si invincible
                if (head.x < 0) head.x = GRID_WIDTH - 1;
                if (head.x >= GRID_WIDTH) head.x = 0;
                if (head.y < 0) head.y = GRID_HEIGHT - 1;
                if (head.y >= GRID_HEIGHT) head.y = 0;
            }
            
            // Collision avec soi-m√™me
            if (game.ghostTimer <= 0 && game.invincibleTimer <= 0) {
                if (game.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    gameOver();
                    return;
                }
            }
            
            game.snake.unshift(head);
            
            // V√©rifier si on mange de la nourriture
            let foodIndex = game.food.findIndex(food => food.x === head.x && food.y === head.y);
            if (foodIndex !== -1) {
                let food = game.food[foodIndex];
                game.food.splice(foodIndex, 1);
                
                // Ajouter des particules
                for (let i = 0; i < 10; i++) {
                    game.particles.push({
                        x: head.x * CELL_SIZE + CELL_SIZE/2,
                        y: head.y * CELL_SIZE + CELL_SIZE/2,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 30,
                        color: FRUIT_TYPES[food.type].color
                    });
                }
                
                // Appliquer l'effet du fruit
                game.score += FRUIT_TYPES[food.type].points;
                
                switch (food.type) {
                    case 'GHOST':
                        game.ghostTimer = 180;
                        break;
                    case 'TELEPORT':
                        game.teleportCharges += 3;
                        break;
                    case 'INVINCIBLE':
                        game.invincibleTimer = 300;
                        break;
                    case 'SHRINK':
                        for (let i = 0; i < 3 && game.snake.length > 1; i++) {
                            game.snake.pop();
                        }
                        break;
                }
                
                game.level = Math.floor(game.score / 15) + 1;
                spawnFood();
            } else {
                game.snake.pop();
            }
            
            // D√©cr√©menter les timers
            if (game.ghostTimer > 0) game.ghostTimer--;
            if (game.invincibleTimer > 0) game.invincibleTimer--;
        }
        
        function teleport() {
            if (game.teleportCharges > 0) {
                let newPos;
                for (let i = 0; i < 100; i++) {
                    newPos = {
                        x: Math.floor(Math.random() * GRID_WIDTH),
                        y: Math.floor(Math.random() * GRID_HEIGHT)
                    };
                    
                    let occupied = game.snake.some(segment => segment.x === newPos.x && segment.y === newPos.y);
                    if (!occupied) {
                        game.snake[0] = newPos;
                        game.teleportCharges--;
                        break;
                    }
                }
            }
        }
        
        function updateParticles() {
            game.particles = game.particles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                return particle.life > 0;
            });
        }
        
        function draw() {
            // Fond
            ctx.fillStyle = game.nightMode ? '#ffffff' : '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Particules
            game.particles.forEach(particle => {
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.life / 30;
                ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            });
            
            // Snake
            game.snake.forEach((segment, index) => {
                let color = '#00ff00';
                if (game.ghostTimer > 0) {
                    ctx.globalAlpha = 0.5 + 0.5 * Math.sin(Date.now() * 0.01);
                } else if (game.invincibleTimer > 0) {
                    color = `hsl(${Date.now() * 0.1 % 360}, 100%, 50%)`;
                }
                
                if (game.nightMode) {
                    color = index === 0 ? '#ff0000' : '#800000';
                }
                
                ctx.fillStyle = color;
                ctx.fillRect(segment.x * CELL_SIZE, segment.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                
                if (index === 0) {
                    // Yeux
                    ctx.fillStyle = game.nightMode ? '#ffffff' : '#000000';
                    ctx.fillRect(segment.x * CELL_SIZE + 5, segment.y * CELL_SIZE + 5, 3, 3);
                    ctx.fillRect(segment.x * CELL_SIZE + 12, segment.y * CELL_SIZE + 5, 3, 3);
                }
                
                ctx.globalAlpha = 1;
            });
            
            // Nourriture
            game.food.forEach(food => {
                let color = FRUIT_TYPES[food.type].color;
                if (game.nightMode) {
                    // Inverser les couleurs en mode nuit
                    let r = 255 - parseInt(color.substr(1, 2), 16);
                    let g = 255 - parseInt(color.substr(3, 2), 16);
                    let b = 255 - parseInt(color.substr(5, 2), 16);
                    color = `rgb(${r}, ${g}, ${b})`;
                }
                
                ctx.fillStyle = color;
                
                // Effet de pulsation pour les power-ups
                if (food.type !== 'NORMAL') {
                    let pulse = 1 + 0.2 * Math.sin(Date.now() * 0.01);
                    let size = CELL_SIZE * pulse;
                    let offset = (CELL_SIZE - size) / 2;
                    ctx.fillRect(food.x * CELL_SIZE + offset, food.y * CELL_SIZE + offset, size, size);
                } else {
                    ctx.fillRect(food.x * CELL_SIZE, food.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            });
            
            // Interface
            document.getElementById('score').textContent = `Score: ${game.score}`;
            document.getElementById('level').textContent = `Niveau: ${game.level}`;
        }
        
        function gameOver() {
            game.gameRunning = false;
            alert(`Game Over! Score final: ${game.score}`);
        }
        
        function togglePause() {
            if (game.gameRunning) {
                game.paused = !game.paused;
            }
        }
        
        function toggleNightMode() {
            game.nightMode = !game.nightMode;
        }
        
        function gameLoop() {
            if (!game.gameRunning) return;
            
            moveSnake();
            updateParticles();
            draw();
            
            let speed = game.sprinting ? 150 : 200;
            setTimeout(gameLoop, speed);
        }
        
        // Contr√¥les clavier
        document.addEventListener('keydown', (e) => {
            if (!game.gameRunning) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    if (game.direction.y !== 1) game.direction = {x: 0, y: -1};
                    break;
                case 'ArrowDown':
                    if (game.direction.y !== -1) game.direction = {x: 0, y: 1};
                    break;
                case 'ArrowLeft':
                    if (game.direction.x !== 1) game.direction = {x: -1, y: 0};
                    break;
                case 'ArrowRight':
                    if (game.direction.x !== -1) game.direction = {x: 1, y: 0};
                    break;
                case ' ':
                    game.sprinting = true;
                    e.preventDefault();
                    break;
                case 't':
                case 'T':
                    teleport();
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
                case 'n':
                case 'N':
                    toggleNightMode();
                    break;
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === ' ') {
                game.sprinting = false;
            }
        });
        
        // D√©marrer le jeu automatiquement
        startGame();
    </script>
</body>
</html>